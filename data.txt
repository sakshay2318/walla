1: /user/123	Detects hardcoded references to IDs in routes, allowing attackers to manipulate the id parameter to access unauthorized resources.	1. Log in as User A. 2. Access /user/123. 3. Change 123 to another valid user ID (/user/456). 4. Check if unauthorized access is granted.	Unauthorized access should be denied with a 403 Forbidden response.	Found that the application lacked ownership validation, allowing access to other users' profiles.	3-4 hours	Implemented access control checks to verify ownership of the requested resource. Added middleware to validate :id against the logged-in user’s access.
IDOR Test Case 2: fetch({id})	Scans for dynamic IDs in API calls (e.g., fetch({id})) without proper authorization checks, exposing sensitive resources.	1. Identify API calls that use fetch({id}). 2. Log in as User A. 3. Change the id parameter to another user’s ID. 4. Observe API response.	The API should reject unauthorized ID modifications with a 403 Forbidden response.	Found that the endpoint accepted modified IDs without verification, exposing unauthorized data.	3-5 hours	Implemented server-side validation to check if the fetched resource belongs to the logged-in user. Added middleware for per-resource access scope validation.
IDOR Test Case 3: req.body.userId	Detects cases where req.body.userId is directly used without ensuring it matches the logged-in user, leading to unauthorized modifications.	1. Identify API endpoints that accept userId in req.body. 2. Log in as User A. 3. Send a request with req.body.userId = B (another user’s ID). 4. Observe if access is granted.	API should validate that userId in the request matches the session user ID. Unauthorized requests should be rejected.	Found that API did not verify userId, allowing unauthorized account changes.	4 hours	Implemented server-side validation to cross-check userId against the logged-in user's session. Applied middleware to validate req.body input before processing.
RBAC Test Case 1: No Role Validation in Routes	Checks for API endpoints (e.g., router.get('/resource')) that do not enforce role-based access control (RBAC).	1. Identify routes that do not include RBAC middleware. 2. Log in as a user without admin privileges. 3. Access an admin-only endpoint.	Access should be denied with a 403 Forbidden response.	Found multiple endpoints that lacked role-based validation, allowing unauthorized access.	2-3 hours	Added role-based middleware to verify that the logged-in user has the necessary permissions for the requested action.
RBAC Test Case 2: Hardcoded Role Tokens	Detects hardcoded role tokens in the codebase that attackers can exploit to bypass role-based restrictions.	1. Search for hardcoded tokens in the code (e.g., if (user.role === "admin")). 2. Modify the token manually in a request. 3. Check if unauthorized access is granted.	The system should verify roles dynamically and not rely on hardcoded values.	Found that role validation was based on hardcoded tokens, allowing unauthorized role elevation.	5-6 hours	Replaced hardcoded tokens with dynamic ones generated and verified via JWT. Implemented middleware-based role validation.
RBAC Test Case 3: Missing Role Validation in DB Operations	Identifies cases where DB operations (e.g., db.find(), db.query()) are performed without verifying user roles, leading to unauthorized data access.	1. Identify DB queries that retrieve sensitive data. 2. Log in as a low-privilege user. 3. Attempt to access unauthorized data by modifying request parameters.	The API should verify roles before executing queries and restrict access based on user privileges.	Found that database queries lacked role validation, allowing unauthorized users to retrieve sensitive data.	4-5 hours	Introduced role-based checks at the database level. Verified user roles and permissions before executing queries.
