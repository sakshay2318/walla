Test Case	Test Case Description	Time Taken to Mitigate	How Did You Mitigate
IDOR Test Case 1: /user/123	The script detects any hardcoded references to IDs in the route /user/:id. This pattern highlights potential vulnerabilities where an attacker can directly manipulate the ID parameter to access unauthorized resources.	3-4 hours	Implemented access control checks to verify the ownership of the requested resource. Added middleware to validate the :id parameter against the logged-in user's access.
IDOR Test Case 2: req.params.id	Scans for the use of req.params.id without validation or ownership verification. This may allow attackers to exploit the application by modifying request parameters to access unauthorized resources.	3 hours	Added a centralized middleware to validate the id in req.params. Ownership checks were implemented to ensure the ID belongs to the current user before proceeding.
IDOR Test Case 3: id=123	Identifies query parameters such as ?id=123 that are not validated for ownership or access permissions. This could lead to unauthorized access or data leakage.	4 hours	Implemented strict input validation using a whitelist and verified that the queried ID exists in the database and is owned by the logged-in user.
IDOR Test Case 4: fetch({id})	Scans for patterns where dynamic IDs (e.g., fetch({id})) are used in API calls without proper authorization checks. This could expose sensitive resources if roles or ownership are not verified.	3-5 hours	Incorporated server-side validation for fetched resources to check the userâ€™s permissions. Added endpoint-specific middleware to validate the access scope for each resource.
IDOR Test Case 5: req.body.userId	Detects direct use of req.body.userId without ensuring that the provided user ID corresponds to the logged-in user. This could result in unauthorized access or data manipulation.	4 hours	Implemented server-side validation to cross-check userId against the logged-in user's session. Applied middleware to validate req.body input before processing the request.
RBAC Test Case 1: No Role Validation in Routes	Checks for API endpoints (e.g., router.get('/resource')) that do not have middleware for role-based access control. This can allow users without proper roles to access resources.	2-3 hours	Added role-based middleware to all routes to verify that the logged-in user has the necessary permissions for the requested resource or action.
RBAC Test Case 2: Sensitive Route Exposure	Identifies sensitive routes such as /admin/settings that are accessible without RBAC enforcement. This can lead to unauthorized users accessing critical application functionalities.	3-5 hours	Enforced role validation checks at sensitive endpoints. Used middleware to ensure only authorized users with specific roles can access these routes.
RBAC Test Case 3: Hardcoded Role Tokens	Detects usage of hardcoded tokens in the codebase for role validation. Hardcoded tokens can be exploited by attackers to bypass role-based restrictions.	5-6 hours	Replaced hardcoded tokens with dynamic tokens generated and verified through a secure authentication mechanism (e.g., JWT). Added checks for role validation in middleware.
RBAC Test Case 4: Missing Role Validation in DB Operations	Identifies cases where database operations (e.g., db.find() or db.query()) are performed without validating the user's role. This may lead to unauthorized data access or manipulation.	4-5 hours	Introduced role-based checks at the database query level. Verified user roles and permissions before performing sensitive queries or returning results.
RBAC Test Case 5: Missing Role Validation in Conditional Rendering	Checks for missing role-based validation in rendering sensitive elements (e.g., <AdminPanel>). This can expose functionality to unauthorized users.	2-3 hours	Implemented conditional rendering based on the user's role. Used state management or backend-rendered flags to control access to sensitive UI components.
